# **【資料2/8】データベース設計書 (v1.1)**

## **1\. 概要**

本資料は、en:gram アプリケーションのクライアントサイド・データベース（IndexedDB / Dexie.js\[cite: db.ts\]）のスキーマを詳細に定義する。

**v1.1 での主な変更点:**

* **複合機能への対応:**  
  * Noteエンティティに、typeの拡張（project, sketch\_image, model\_3d, url等）を行う。  
  * ノートの階層化・グループ化のため projectId を追加。  
  * ノートのコンテキスト（場所、タスク状態）のため location, isCompleted を追加。  
  * ノートの管理のため status（アーカイブ機能）を追加。  
* **Engrammer連携の強化:**  
  * Relationエンティティに、Engrammer\[cite: engram\_system\_overview\_v1.1.md\]（LangGraph\[cite: LangChain/LangGraph 1.0 詳細調査計画\]）との連携を強化するため、engrammerThreadId を追加。  
  * Relationエンティティに、ユーザーによる「手動接続」\[cite: 複合機能提案\]と「粒度の高いフィードバック」\[cite: 複合機能提案\]を記録するため、userReasoning を追加。

## **2\. データベースライブラリ**

* **Dexie.js (v4+)**: IndexedDBの高性能ラッパー。useLiveQuery\[cite: App.tsx\]フックによるReactとのシームレスな連携、および堅牢なスキーマ管理のために採用する。

## **3\. エンティティ（テーブル）定義**

### **3.1. notes テーブル (v1.1)**

Noteエンティティは、ユーザーの思考の最小単位を格納する。

**スキーマ定義 (EngramDB extends Dexie 内):**

// (Dexie.js の version().stores() ブロック内の定義)  
notes: '++id, projectId, type, status, createdAt, embeddingStatus, insightStatus, \[projectId+status+createdAt\]'

**TypeScript インターフェース定義:**

/\*\*  
 \* ノートの種別 (v1.1)  
 \* 複合機能\[cite:複合機能提案\]に対応  
 \*/  
export type NoteType \=   
  | 'text'          // 通常のテキスト \[cite: db.ts\]  
  | 'image'         // アップロードされた画像 \[cite: db.ts\]  
  | 'audio'         // 音声（v1.1では録音データBlob） \[cite: db.ts\]  
  | 'url'           // URL（WebClipper\[cite:複合機能提案\]またはペースト）  
  | 'sketch\_image'  // スケッチ入力\[cite:複合機能提案\]（画像Blobとして保存）  
  | 'model\_3d'      // 3Dモデル\[cite:複合機能提案\]（.stl/.obj Blobとして保存）  
  | 'task'          // タスク（チェックボックス付き）\[cite:複合機能提案\]  
  | 'project'       // プロジェクト・コンテナ（複合機能\#1）  
  | 'project\_summary'; // プロジェクトのAI自動要約

/\*\*  
 \* ノートの状態 (v1.1)  
 \* アーカイブ機能（複合機能\#10 UX）に対応  
 \*/  
export type NoteStatus \= 'active' | 'archived';

/\*\*  
 \* AI処理パイプラインのステータス  
 \*/  
export type ProcessingStatus \= 'pending' | 'completed' | 'failed' | 'n/a';

/\*\*  
 \* Note エンティティ (v1.1)  
 \*/  
export interface Note {  
  // \--- 基本情報 \---  
  id: string;              // 主キー (UUID v4, \`creating\` フックで自動生成\[cite:db.ts\])  
  createdAt: Date;         // 作成日時 (\`creating\` フックで自動生成\[cite:db.ts\])  
  updatedAt: Date;         // 更新日時 (\`updating\` フックで自動更新)

  // \--- コンテンツ \---  
  type: NoteType;          // ノート種別  
  content: string | Blob;  // ノート本体 (text, url, project\_summary は string, 他は Blob)  
  autoCaption?: string;    // (v1.1 新規) 画像キャプション\[cite:複合機能提案\]の自動生成結果

  // \--- 階層化・管理 (v1.1 新規) \---  
  projectId: string | null;  // (複合機能\#1) 所属するプロジェクトのID (Note.id)  
  status: NoteStatus;      // (複合機能\#10 UX) 'active' | 'archived'  
  isPinned: boolean;       // (複合機能\#11 UX) ピン留め状態

  // \--- コンテキスト (v1.1 新規) \---  
  location: string | null;     // (複合機能\#15 UX) ノート作成場所 (例: "大阪市"\[cite:user\_provided\_info\])  
  isCompleted: boolean;    // (複合機能\#8 UX) \`type: 'task'\` の場合の完了状態  
    
  // \--- AI 処理パイプライン \---  
  embedding?: number\[\];     // (Vertex AI) コンテンツのベクトル表現  
  embeddingStatus: ProcessingStatus; // Embedding処理の状態  
  insightStatus: ProcessingStatus;   // 自動接続(getInsightSuggestions\[cite:engram\_client\_ai\_logic\_v1.1.md\])の処理状態  
}

### **3.2. relations テーブル (v1.1)**

Relationエンティティは、2つの Note エンティティ間の「繋がり（響き）」を格納する。

**スキーマ定義 (EngramDB extends Dexie 内):**

// (Dexie.js の version().stores() ブロック内の定義)  
relations: '++id, \[sourceId+targetId\], sourceId, targetId, projectId, source, feedback, engrammerThreadId'

**TypeScript インターフェース定義:**

/\*\*  
 \* 繋がりの生成元  
 \*/  
export type RelationSource \= 'ai\_suggestion' | 'user\_manual'; // (手動接続\[cite:複合機能提案\]に対応\[cite:data-model.md\])

/\*\*  
 \* AIの提案に対するユーザーフィードバック  
 \*/  
export type RelationFeedback \= 'pending' | 'useful' | 'harmful' | 'edited'; // (粒度の高いFB\[cite:複合機能提案\]用に 'edited' を追加)

/\*\*  
 \* Relation エンティティ (v1.1)  
 \*/  
export interface Relation {  
  // \--- 基本情報 \---  
  id: string;              // 主キー (UUID v4, \`creating\` フックで自動生成\[cite:db.ts\])  
  createdAt: Date;         // 作成日時 (\`creating\` フックで自動生成\[cite:db.ts\])

  // \--- 接続情報 \---  
  sourceId: string;        // 接続元ノートID (Note.id)  
  targetId: string;        // 接続先ノートID (Note.id)  
  projectId: string | null;// (v1.1 新規) この接続が属するプロジェクトID（関連ノートが同じプロジェクトの場合）

  // \--- AI / ユーザー情報 \---  
  source: RelationSource;    // 'ai\_suggestion' (自動) または 'user\_manual' (手動\[cite:複合機能提案\])  
  reasoning: string;         // AIが生成した接続理由\[cite:data-model.md\]  
  userReasoning?: string;    // (v1.1 新規) ユーザーが手動接続時に入力、またはAIの理由を編集した内容 (粒度の高いFB\[cite:複合機能提案\])  
  feedback: RelationFeedback;// ユーザーからのフィードバック\[cite:data-model.md\]

  // \--- Engrammer 連携 (v1.1 新規) \---  
  engrammerThreadId: string | null; // この接続の発見/分析につながった Engrammer\[cite:engram\_system\_overview\_v1.1.md\] の \`thread\_id\`\[cite:LangChain/LangGraph 1.0 詳細調査計画\]  
}

## **4\. EngramDB クラス定義 (v1.1)**

Dexie.js を拡張し、カスタムフックとクエリメソッドを定義する。

import Dexie, { type Table } from 'dexie';  
import { v4 as uuidv4 } from 'uuid';

// \--- インターフェース定義 (上記 3.1, 3.2 をここに挿入) \---  
export type NoteType \= ...  
export type NoteStatus \= ...  
export type ProcessingStatus \= ...  
export interface Note { ... }  
export type RelationSource \= ...  
export type RelationFeedback \= ...  
export interface Relation { ... }

// \--- Dexie 拡張クラス \---

class EngramDB extends Dexie {  
  notes\!: Table\<Note\>;  
  relations\!: Table\<Relation\>;

  constructor() {  
    super('EngramDB\_v1\_1'); // (v1.0 からDB名を変更またはマイグレーション)  
      
    this.version(1).stores({  
      notes: '++id, projectId, type, status, createdAt, embeddingStatus, insightStatus, \[projectId+status+createdAt\]',  
      relations: '++id, \[sourceId+targetId\], sourceId, targetId, projectId, source, feedback, engrammerThreadId',  
    });

    // \--- 自動化フック \---  
    this.setupHooks();  
  }

  private setupHooks(): void {  
    // 1\. Note: 作成フック  
    this.notes.hook('creating', (primKey, obj) \=\> {  
      const now \= new Date();  
      obj.id \= uuidv4();  
      obj.createdAt \= now;  
      obj.updatedAt \= now;  
      // デフォルト値の設定  
      if (obj.projectId \=== undefined) obj.projectId \= null;  
      if (obj.status \=== undefined) obj.status \= 'active';  
      if (obj.isPinned \=== undefined) obj.isPinned \= false;  
      if (obj.location \=== undefined) obj.location \= null;  
      if (obj.isCompleted \=== undefined) obj.isCompleted \= false;  
      if (obj.embeddingStatus \=== undefined) obj.embeddingStatus \= 'pending';  
      if (obj.insightStatus \=== undefined) obj.insightStatus \= (obj.type \=== 'project' || obj.type \=== 'task') ? 'n/a' : 'pending';  
    });

    // 2\. Note: 更新フック  
    this.notes.hook('updating', (modifications, primKey, obj) \=\> {  
      // \`updatedAt\` のみを自動更新  
      return { ...modifications, updatedAt: new Date() };  
    });

    // 3\. Relation: 作成フック  
    this.relations.hook('creating', (primKey, obj) \=\> {  
      const now \= new Date();  
      obj.id \= uuidv4();  
      obj.createdAt \= now;  
      // デフォルト値の設定  
      if (obj.projectId \=== undefined) obj.projectId \= null;  
      if (obj.source \=== undefined) obj.source \= 'ai\_suggestion';  
      if (obj.feedback \=== undefined) obj.feedback \= 'pending';  
      if (obj.engrammerThreadId \=== undefined) obj.engrammerThreadId \= null;  
    });  
  }

  // \--- カスタムクエリメソッド (v1.1) \---

  /\*\*  
   \* ノート一覧をページネーションで取得  
   \* (アーカイブ\[cite:複合機能提案\]、ピン留め\[cite:複合機能提案\]、プロジェクト\[cite:複合機能提案\]を考慮)  
   \*/  
  async getPaginatedNotes(  
    projectId: string | null,  
    offset: number,  
    limit: number  
  ): Promise\<Note\[\]\> {  
    let query \= this.notes  
      .where('projectId')  
      .equals(projectId)  
      .and(note \=\> note.status \=== 'active')  
      .orderBy('createdAt')  
      .reverse();  
        
    // TODO: ピン留め (\`isPinned\`) を \`orderBy\` の最優先にするロジック  
      
    return query.offset(offset).limit(limit).toArray();  
  }

  /\*\*  
   \* 関連ノート一覧をページネーションで取得  
   \*/  
  async getPaginatedRelations(  
    projectId: string | null,  
    offset: number,  
    limit: number  
  ): Promise\<Relation\[\]\> {  
    return this.relations  
      .where('projectId')  
      .equals(projectId)  
      .orderBy('createdAt')  
      .reverse()  
      .offset(offset)  
      .limit(limit)  
      .toArray();  
  }  
    
  /\*\*  
   \* 単一ノートに関連するすべての Relation を取得  
   \*/  
  async getRelationsForNote(noteId: string): Promise\<Relation\[\]\> {  
    const fromSource \= this.relations.where('sourceId').equals(noteId).toArray();  
    const fromTarget \= this.relations.where('targetId').equals(noteId).toArray();  
      
    const \[sourceRelations, targetRelations\] \= await Promise.all(\[fromSource, fromTarget\]);  
      
    // 重複を削除してマージ  
    const allRelationsMap \= new Map\<string, Relation\>();  
    sourceRelations.forEach(r \=\> allRelationsMap.set(r.id, r));  
    targetRelations.forEach(r \=\> allRelationsMap.set(r.id, r));  
      
    return Array.from(allRelationsMap.values());  
  }

  /\*\*  
   \* ノートをアーカイブ\[cite:複合機能提案\]する (ステータス更新)  
   \*/  
  async archiveNote(noteId: string): Promise\<void\> {  
    await this.notes.update(noteId, { status: 'archived' });  
  }

  /\*\*  
   \* 手動接続\[cite:複合機能提案\]を追加する  
   \*/  
  async addManualRelation(  
    sourceId: string,   
    targetId: string,   
    projectId: string | null,  
    userReasoning: string  
  ): Promise\<string\> {  
    const relationToAdd: Omit\<Relation, 'id' | 'createdAt'\> \= {  
      sourceId,  
      targetId,  
      projectId,  
      source: 'user\_manual',  
      reasoning: userReasoning, // ユーザーの理由を reasoning にもコピー  
      userReasoning: userReasoning,  
      feedback: 'useful', // ユーザーが作成したものは自動で 'useful'  
      engrammerThreadId: null,  
    };  
    return this.relations.add(relationToAdd as any);  
  }

  /\*\*  
   \* 粒度の高いフィードバック\[cite:複合機能提案\]を更新する  
   \*/  
  async updateRelationFeedback(  
    id: string,   
    feedback: RelationFeedback,   
    userReasoning?: string  
  ): Promise\<void\> {  
    const modifications: Partial\<Relation\> \= { feedback };  
    if (userReasoning) {  
      modifications.userReasoning \= userReasoning;  
      modifications.feedback \= 'edited'; // フィードバック種別を 'edited' に変更  
    }  
    await this.relations.update(id, modifications);  
  }  
}

// シングルトンインスタンスをエクスポート  
const db \= new EngramDB();

// 開発モード\[cite:db.ts\]では window オブジェクトに公開  
if (import.meta.env.DEV) {  
  (window as any).db \= db;  
}

export default db;

## **5\. 説明**

### **5.1. Note エンティティの変更点**

* type: NoteType (拡張):  
  'text', 'image', 'audio'\[cite: db.ts\] に加え、複合機能で合意した 'url' (WebClipper\[cite: 複合機能提案\]), 'sketch\_image' (スケッチ\[cite: 複合機能提案\]), 'model\_3d' (3Dモデル\[cite: 複合機能提案\]), 'task' (タスク\[cite: 複合機能提案\]), 'project' (プロジェクトコンテナ\[cite: 複合機能提案\]) を追加しました。これにより、あなたの「ものづくり」\[cite: user\_provided\_info\]の全プロセス（アイデア、スケッチ、3Dモデル、タスク管理、プロジェクト管理）を記録できます。  
* autoCaption: string (新規):  
  複合機能「画像キャプション自動生成」\[cite: 複合機能提案\]のため、AIが生成したキャプションを保存するフィールドです。  
* projectId: string | null (新規):  
  複合機能「プロジェクト」\[cite: 複合機能提案\]（機能\#1）のため、各ノートがどのプロジェクトに属するかを示す外部キーです。nullの場合はどのプロジェクトにも属しません。  
* status: NoteStatus (新規):  
  複合機能「アーカイブ」\[cite: 複合機能提案\]（UX改善\#10）のため、ノートの状態（'active' | 'archived'）を管理します。deleteNote\[cite: App.tsx\]は物理削除ではなく、このステータスの更新になります。  
* isPinned: boolean (新規):  
  複合機能「ピン留め」\[cite: 複合機能提案\]（UX改善\#11）のため。  
* location: string | null (新規):  
  複合機能「場所ノート」\[cite: 複合機能提案\]（UX改善\#15）のため。あなたの地理的コンテキスト（例: 大阪市, 豊中市）\[cite: user\_provided\_info\]を記録します。  
* isCompleted: boolean (新規):  
  複合機能「タスク」\[cite: 複合機能提案\]（UX改善\#8）のため。type: 'task' のノートが完了したかを示します。  
* updatedAt: Date (新規):  
  ノートの最終更新日時を追跡するため。Dexieのupdatingフックで自動更新されます。

### **5.2. Relation エンティティの変更点**

* projectId: string | null (新規):  
  Noteと同様に、この「繋がり」がどのプロジェクト内で発生したかを記録します。プロジェクトビューでの絞り込みに使います。  
* userReasoning: string (新規):  
  複合機能「粒度の高いフィードバック」\[cite: 複合機能提案\]（UX改善\#7）と「手動接続」\[cite: 複合機能提案\]（機能\#2）のため。AIのreasoning\[cite: data-model.md\]をユーザーが編集した内容、または手動接続時にユーザーが入力した理由を保存します。これはEngrammer\[cite: engram\_system\_overview\_v1.1.md\]の「内省者」\[cite: ACEアルゴリズムJavaScript実装ガイド.md\]にとって最も価値のある学習データとなります。  
* feedback: RelationFeedback (拡張):  
  'edited' を追加し、ユーザーが理由を編集した（最も価値の高い）フィードバックであることを示します。  
* engrammerThreadId: string | null (新規):  
  LangGraph 1.0\[cite: LangChain/LangGraph 1.0 詳細調査計画\]のCheckpointer\[cite: LangChain/LangGraph 1.0 詳細調査計画\]と連携するため。このRelationがEngrammer\[cite: engram\_system\_overview\_v1.1.md\]のどの対話スレッド（thread\_id\[cite: LangChain/LangGraph 1.0 詳細調査計画\]）によって生成されたか、または分析されたかを紐付けます。これにより、UIから「この繋がりが生まれたEngrammerの思考プロセスを見る」といった将来的な連携が可能になります。

### **5.3. EngramDB クラスの変更点**

* **version(1):** v1.1の新しいスキーマでバージョン1として定義します（または本番ではマイグレーション処理を記述します）。  
* **フック (setupHooks):** creatingフックで、v1.1で追加された全フィールド（projectId, status, locationなど）のデフォルト値を設定し、コードの堅牢性を高めます。updatingフックでupdatedAtを自動更新します。  
* **カスタムクエリ:** getPaginatedNotes と getPaginatedRelations が projectId で絞り込みできるように変更。getRelationsForNote（ノートに関連する全接続を取得）、archiveNote、addManualRelation、updateRelationFeedback など、v1.1の機能に必要なDB操作メソッドをクラス内にカプセル化し、App.tsx\[cite: App.tsx\]から呼び出しやすくします。