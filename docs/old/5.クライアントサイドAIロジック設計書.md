# **【資料5/8】クライアントサイドAIロジック設計書の説明**

この資料 (engram\_client\_ai\_logic.md) は、en:gram アプリケーションのフロントエンドで実行される AI 関連の処理について、そのアルゴリズムと実装方法を詳細に定義します。

**主な内容:**

1. **類似ノート検索 (similarity.ts):**  
   * ノート間の意味的な類似度を計算するための **コサイン類似度** アルゴリズムの実装方法を定義しています。  
   * findSimilarNotes 関数は、与えられたノートに対して、データベース内の他のノートとの類似度を計算し、類似度が高い順に指定された件数を返します。これは、後述のハイブリッドAIエンジンが適切な文脈で推論を行うために使用されます。  
2. **ハイブリッドAIインサイトエンジン (App.tsx 内 getInsightSuggestions):**  
   * en:gram の中核機能である「繋がり発見」を実現するロジックです。  
   * **ハイブリッド戦略:** まず、ブラウザ内蔵のAI (window.LanguageModel / Gemini Nano) を使用しようと試みます (try ブロック)。  
   * **利用可能性チェック:** LanguageModel.availability() API を呼び出して、オンデバイスAIが利用可能かを確認します。  
   * **プロンプト構築:** オンデバイスAI、クラウドAI双方に共通の指示（役割、タスク、禁止事項、**厳格なJSON出力形式**）を与えるプロンプトを定義します。  
   * **クラウドフォールバック:** オンデバイスAIが利用できない場合 (catch ブロック)、自動的に Firebase Cloud Functions (findConnectionsCloud) に処理を引き継ぎます。画像ノートの場合は、ここで blobToBase64 変換が行われます。  
   * この関数は、バックグラウンド Insight ワーカーから呼び出されます。  
3. **繋がり保存 (App.tsx 内 saveSuggestions):**  
   * getInsightSuggestions が返した繋がりの提案 (ConnectionSuggestion\[\]) を、データベース (db.ts) の relations テーブルに保存するための関数です。  
   * db.relations.bulkAdd を使用して効率的に複数のデータを追加します。  
4. **バックグラウンド Embedding ワーカー (App.tsx 内 useEffect):**  
   * 新しいノートが追加された後、その内容をベクトル化（Embedding）する処理を非同期で行うためのワーカーです。  
   * useLiveQuery を使って embeddingStatus: 'pending' のノートを監視し、検出すると Firebase Cloud Function (embedNoteUrl) を呼び出して Embedding を取得し、DBを更新します。  
   * 一度に1つのノートのみを処理することで、リソースの消費を抑えます。  
5. **バックグラウンド Insight ワーカー (App.tsx 内 useEffect):**  
   * Embedding が完了したノート (embeddingStatus: 'completed', insightStatus: 'pending') を監視し、getInsightSuggestions 関数を呼び出して繋がりの分析を実行するワーカーです。  
   * isAiWorking フラグを使用して、複数のAI処理が同時に実行されるのを防ぎます。  
   * 処理が完了または失敗したら、ノートの insightStatus を更新します。

LLMへの実装指示:  
この設計書に基づき、src/similarity.ts ファイル全体と、src/App.tsx ファイル内のAI関連ロジック（getInsightSuggestions, saveSuggestions, Embeddingワーカー useEffect, Insightワーカー useEffect, blobToBase64 ヘルパー関数）を実装してください。

# **en:gram クライアントサイドAIロジック設計書**

バージョン: 1.0

作成日: 2025-10-29

**目的:**

* en:gramアプリケーションのクライアントサイド (React/TypeScript) で実行されるAI関連機能のロジックと実装方法を詳細に定義する。  
* ハイブリッドAIインサイトエンジン (getInsightSuggestions) のアルゴリズム、コンテキスト構築、オンデバイスAI (LanguageModel API) 呼び出し、クラウドフォールバック処理を規定する。  
* バックグラウンドでのEmbedding生成とInsight分析ワーカーの動作を定義する。  
* AIエージェント (LLM) がこの仕様書を読み込み、App.tsx 内のAI関連関数および similarity.ts を実装できるようにする。

**参照資料:**

* 【資料1/8】システム概要とアーキテクチャ設計書  
* 【資料2/8】データベース設計書 (engram\_database\_design.ts)  
* 【資料3/8】フロントエンド基本設計書  
* 【資料4/8】主要UIコンポーネント詳細設計書  
* spec.md, Agents.md, firebase.ts

## **1\. 類似ノート検索 (src/similarity.ts)**

* **目的:** 新規ノート (targetNote) に対し、既存ノート (allNotes) の中から意味的に類似するノートを k 件発見する。これは getInsightSuggestions 関数でAIへのコンテキストとして使用される。  
* **ファイル:** src/similarity.ts  
* **主要関数:** findSimilarNotes(targetNote: Note, allNotes: Note\[\], k: number): Note\[\]  
* **アルゴリズム:**  
  * targetNote の embedding が存在しない場合は空配列 \[\] を返す。  
  * allNotes をループ処理する。  
    * 各 note について、note.id が targetNote.id と一致する場合、または note.embedding が存在しない場合はスキップする。  
    * cosineSimilarity(targetNote.embedding, note.embedding) を計算する。  
    * 結果を { note: Note, similarity: number } の形式で配列 similarities に格納する。  
  * similarities 配列を similarity の降順でソートする。  
  * ソートされた配列の先頭から k 件を取得し、Note オブジェクトのみを抽出した配列を返す。  
* **補助関数:**  
  * dotProduct(vecA: number\[\], vecB: number\[\]): number: 2つのベクトル（数値配列）の内積を計算する。  
  * magnitude(vec: number\[\]): number: ベクトル（数値配列）のマグニチュード（大きさ）を計算する。  
  * cosineSimilarity(vecA: number\[\], vecB: number\[\]): number: 上記2つの関数を使用し、2つのベクトルのコサイン類似度 (0〜1) を計算する。ベクトルが存在しない、またはマグニチュードが0の場合は 0 を返す。  
* **LLMへの実装指示:** 上記アルゴリズムに基づき、src/similarity.ts ファイルを実装してください。型定義は src/db.ts (Note 型) を参照してください。

## **2\. ハイブリッドAIインサイトエンジン (src/App.tsx 内)**

* **目的:** 新規ノートが追加された後、既存ノートとの「繋がり (Relation)」をAIを用いて発見する。オンデバイスAI (Gemini Nano) を優先的に使用し、利用不可の場合はクラウドAI (Firebase Functions) にフォールバックする。  
* **主要関数:** getInsightSuggestions(newNote: Note): Promise\<void\>  
* **アルゴリズム:**  
  1. **AI処理中フラグ設定:** setIsAiWorking(true) を呼び出す。  
  2. **コンテキスト構築:**  
     * db.notes.where('embeddingStatus').equals('completed').and(note \=\> note.id \!== newNote.id).toArray() を呼び出し、Embeddingが完了している既存ノートを取得する (allDbNotes)。  
     * findSimilarNotes(newNote, allDbNotes, 5\) を呼び出し、類似度上位5件のノートを取得する (contextNotes)。  
     * contextNotes が空の場合は、「Not enough context notes」とログ出力し、setIsAiWorking(false) を呼び出して処理を終了する。  
  3. **プロンプト定義:** AIモデル (オンデバイス/クラウド共通) に与えるシステムプロンプト (textPrompt) を定義する。内容は以下の通り。  
     * 役割: en:gram のAIアシスタントであること。  
     * タスク: 新規ノートと既存ノート間の、表面的でない、洞察に満ちた、あるいは驚きのある繋がりを最大3件発見すること。  
     * 禁止事項: 単純なキーワードマッチングに基づく提案は避けること。  
     * 出力形式: **必須:** \[{ "id": "note-abc", "reason": "This note expands on the concept of..." }\] という形式のJSON配列文字列**のみ**を出力すること。見つからない場合は空配列 \[\] を出力すること。Markdownのコードブロック (json ... ) は含めないこと。  
  4. **オンデバイスAI試行 (try ブロック):**  
     * **利用可能性チェック:** window.LanguageModel が存在するか確認。存在しない場合は Error('On-device AI (LanguageModel) not available.') をスローする。  
     * LanguageModel.availability() を呼び出し、結果 (availability) をログ出力する。  
     * availability が 'no' の場合は Error('On-device model not available...') をスローする。  
     * availability が 'downloadable' の場合は警告ログを出力する。  
     * **セッション作成:** LanguageModel.create() を呼び出して session オブジェクトを取得する。  
     * **入力データ準備:**  
       * newNote と contextNotes の内容をJSON文字列に変換する (newNoteString, contextNotesString)。画像ノートの場合は、コンテンツを含めず type: 'image' と description: "Image note content..." のみを含める。  
     * **最終プロンプト構築:** textPrompt, newNoteString, contextNotesString を結合して最終的なプロンプト文字列 (finalStringPrompt) を作成する。  
     * **オンデバイス推論:** session.prompt(finalStringPrompt) を呼び出す。  
     * **結果パース:**  
       * 応答 (rawResult) を取得。  
       * 応答文字列から、もし含まれていれば json を除去する (jsonString)。  
       * JSON.parse(jsonString) を実行し、結果を ConnectionSuggestion\[\] 型 ({ targetNoteId: item.id, reasoning: item.reason }) に変換する (suggestions)。パース失敗時は空配列 \[\] とする。  
     * saveSuggestions(suggestions, newNote) を呼び出す。  
     * 「Got suggestions from on-device AI」とログ出力する。  
  5. **クラウドフォールバック (catch ブロック):**  
     * オンデバイスAI試行中に発生したエラー (error) を捕捉する。  
     * 「On-device AI failed, falling back to cloud.」と警告ログを出力する。  
     * **リクエストデータ準備 (requestData: FindConnectionsRequest):**  
       * newNote: { id: newNote.id, content: newNote.content as string, type: newNote.type } (※画像の場合は文字列化しない。Blobのまま渡す想定だったが、クラウド関数側でBase64を期待するため、ここで変換が必要)。-\> **修正:** 画像の場合、blobToBase64(newNote.content as Blob) を呼び出してBase64文字列に変換する。  
       * contextNotes: contextNotes 配列をマップし、各ノートについて、画像の場合は blobToBase64 でBase64文字列に変換し、{ id, content, type } の形式にする。  
     * **クラウド関数呼び出し:** findConnectionsCloud(requestData) を呼び出す (firebase.ts からインポート)。  
     * **結果取得:** 結果 (result.data) を ConnectionSuggestion\[\] 型として取得する (suggestions)。  
     * saveSuggestions(suggestions, newNote) を呼び出す。  
     * 「Got suggestions from cloud AI」とログ出力する。  
     * クラウドフォールバックも失敗した場合は、エラーをコンソールに出力し、再度エラーをスローする (バックグラウンドワーカーで insightStatus: 'failed' にするため)。  
  6. **AI処理中フラグ解除:** finally ブロックで setIsAiWorking(false) を呼び出す。  
* **LLMへの実装指示:** 上記アルゴリズムに基づき、App.tsx 内に getInsightSuggestions 関数を実装してください。Note, ConnectionSuggestion, FindConnectionsRequest 型は適宜定義またはインポートしてください。blobToBase64 ヘルパー関数も App.tsx 内に実装してください。findSimilarNotes, findConnectionsCloud, saveSuggestions を適切に呼び出してください。

## **3\. 繋がり保存 (src/App.tsx 内)**

* **目的:** getInsightSuggestions で得られた ConnectionSuggestion 配列をデータベースに Relation として保存する。  
* **主要関数:** saveSuggestions(suggestions: ConnectionSuggestion\[\], sourceNote: Note): Promise\<void\>  
* **アルゴリズム:**  
  1. suggestions が空配列の場合は何もせず終了する。  
  2. suggestions 配列をマップし、各 suggestion を Relation オブジェクト (ただし id と createdAt を除く) に変換する (relationsToAdd)。  
     * sourceId: sourceNote.id  
     * targetId: suggestion.targetNoteId  
     * source: 'ai\_suggestion'  
     * reasoning: suggestion.reasoning  
     * feedback: 'pending' (デフォルト値)  
  3. db.relations.bulkAdd(relationsToAdd as any) を呼び出して、複数の関連性を一括でデータベースに追加する。  
  4. 「Saved new relations to the database.」とログ出力する。  
* **LLMへの実装指示:** 上記アルゴリズムに基づき、App.tsx 内に saveSuggestions 関数を実装してください。Relation 型は db.ts からインポートしてください。

## **4\. バックグラウンド Embedding ワーカー (src/App.tsx 内)**

* **目的:** embeddingStatus: 'pending' のノートを検出し、バックグラウンドでEmbeddingを生成・保存する。  
* **トリガー:** useLiveQuery(() \=\> db.notes.where('embeddingStatus').equals('pending').limit(1).toArray(), \[\]) で取得した pendingEmbeddingNotes の変化を検出する useEffect フック。  
* **アルゴリズム:**  
  1. pendingEmbeddingNotes が存在しない、または空の場合は何もしない。  
  2. 配列の最初のノート (noteToProcess \= pendingEmbeddingNotes\[0\]) を処理対象とする。  
  3. try ブロック:  
     * 「Processing embedding for note: ...」とログ出力する。  
     * noteToProcess.type に応じて payload を作成する:  
       * 'text': { type: 'text', content: noteToProcess.content as string }  
       * 'image': blobToBase64(noteToProcess.content as Blob) を呼び出し、{ type: 'image', content: base64Image }  
       * それ以外: Error('Unsupported type for embedding') をスローする。  
     * fetch(embedNoteUrl, { method: 'POST', ..., body: JSON.stringify({ data: payload }) }) を呼び出す (firebase.ts から embedNoteUrl をインポート)。  
     * レスポンスが ok でない場合はエラーをスローする。  
     * レスポンスボディ (result.data) を number\[\] 型の embedding として取得する。  
     * db.notes.update(noteToProcess.id, { embedding: embedding, embeddingStatus: 'completed', insightStatus: 'pending' }) を呼び出してDBを更新する。  
     * 「Embedding saved for note: ...」とログ出力する。  
  4. catch ブロック:  
     * エラーをコンソールに出力する。  
     * db.notes.update(noteToProcess.id, { embeddingStatus: 'failed' }) を呼び出してDBを更新する。  
* **LLMへの実装指示:** 上記アルゴリズムに基づき、App.tsx 内に Embedding ワーカーの useEffect フックを実装してください。useLiveQuery, db, blobToBase64, embedNoteUrl を適切に使用してください。一度に1つのノートのみを処理するようにしてください (並列処理はしない)。

## **5\. バックグラウンド Insight ワーカー (src/App.tsx 内)**

* **目的:** embeddingStatus: 'completed' かつ insightStatus: 'pending' のノートを検出し、バックグラウンドで getInsightSuggestions を呼び出して関連性を分析・保存する。  
* **トリガー:** useLiveQuery(() \=\> db.notes.where({ embeddingStatus: 'completed', insightStatus: 'pending' }).limit(1).toArray(), \[\]) で取得した pendingInsightNotes の変化を検出する useEffect フック。isAiWorking フラグも依存配列に含め、AI処理中の重複実行を防ぐ。  
* **アルゴリズム:**  
  1. pendingInsightNotes が存在しない、または空の場合、または isAiWorking が true の場合は何もしない。  
  2. 配列の最初のノート (noteToProcess \= pendingInsightNotes\[0\]) を処理対象とする。  
  3. setIsAiWorking(true) を呼び出す (重複実行防止とUIスピナー表示のため)。  
  4. try ブロック:  
     * 「Processing insights for note: ...」とログ出力する。  
     * await getInsightSuggestions(noteToProcess) を呼び出す。  
     * await db.notes.update(noteToProcess.id, { insightStatus: 'completed' }) を呼び出してDBを更新する。  
     * 「Insights saved for note: ...」とログ出力する。  
  5. catch ブロック:  
     * エラーをコンソールに出力する。  
     * await db.notes.update(noteToProcess.id, { insightStatus: 'failed' }) を呼び出してDBを更新する。  
  6. finally ブロック:  
     * setIsAiWorking(false) を呼び出す。  
* **LLMへの実装指示:** 上記アルゴリズムに基づき、App.tsx 内に Insight ワーカーの useEffect フックを実装してください。useLiveQuery, db, getInsightSuggestions, isAiWorking, setIsAiWorking を適切に使用してください。一度に1つのノートのみを処理するようにしてください。

