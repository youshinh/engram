# **【資料2/8】データベース設計書の説明**

この資料 (engram\_database\_design.ts) は、en:gram アプリケーションで使用されるクライアントサイドデータベース (IndexedDB) の構造と、それを操作するための Dexie.js の設定を定義します。

**主な内容:**

1. **エンティティ定義 (Note, Relation):**  
   * アプリケーションで扱うデータの型 (interface) を TypeScript で定義しています。  
   * 以前の定義に加え、複合機能を実現するために必要な新しいフィールド（projectId, location, status, isPinned, tags, isCompleted, summary, strength, userCorrectedReasoning など）が追加されています。  
   * 新しいノート種別 (url, project, task, workshop) も定義されています。  
   * WorkshopContent インターフェースは、workshop タイプのノートの content フィールドに JSON 文字列として格納されるデータの構造を定義します。  
2. **Dexie.js データベースクラス (EngramDB):**  
   * Dexie を継承して、EngramDB という名前のデータベースクラスを定義しています。  
   * version(5).stores({...}) で、notes と relations という2つのテーブル（オブジェクトストア）と、それぞれのインデックスを定義しています。  
     * インデックスは、データの検索やソートを高速化するために重要です。特に、バックグラウンド処理用の複合インデックス \[embeddingStatus+insightStatus\] や、プロジェクト機能用の projectId などが定義されています。  
   * upgrade 関数内で、以前のバージョン (v4) からのスキーマ変更（フィールド追加とデフォルト値設定）を処理するマイグレーションロジックが記述されています。  
3. **ヘルパーメソッド:**  
   * データの取得や更新を容易にするための便利なメソッド (getPaginatedNotes, countNotes, updateRelationFeedback など) が EngramDB クラス内に実装されています。これらは App.tsx などから利用されます。  
4. **Dexie Hooks:**  
   * db.notes.hook('creating', ...) や db.relations.hook('creating', ...) を使用して、新しいデータがテーブルに追加される際に自動的に実行される処理を定義しています。  
   * これにより、id (UUID) や createdAt (現在日時)、status (デフォルト: 'active') などのフィールドが自動的に設定され、アプリケーションコードでの記述を簡略化します。  
5. **エクスポート:**  
   * EngramDB クラスのシングルトンインスタンス db をデフォルトエクスポートしており、アプリケーション全体でこのインスタンスを共有してデータベースにアクセスします。  
   * 開発モード (import.meta.env.DEV) の場合に限り、ブラウザの開発者ツールからデータベースを直接操作できるよう、window.db にインスタンスを公開しています。

LLMへの指示:  
この engram\_database\_design.ts ファイルの内容をそのまま src/db.ts として実装してください。型定義、クラス定義、スキーマ、フック、メソッドをすべて含めてください。  
/\*\*  
 \* en:gram データベース設計書 (Dexie.js / IndexedDB)  
 \*  
 \* バージョン: 1.0  
 \* 作成日: 2025-10-29  
 \*  
 \* 目的:  
 \* \- en:gramアプリケーションで使用するクライアントサイドデータベースのスキーマを定義する。  
 \* \- Dexie.jsを用いた実装方法を具体的に指定する。  
 \* \- AIエージェント（LLM）がこの仕様書を読み込み、\`src/db.ts\`ファイルを生成できるようにする。  
 \*  
 \* 参照資料:  
 \* \- 【資料1/8】システム概要とアーキテクチャ設計書  
 \* \- 既存の \`db.ts\`, \`data-model.md\` ファイル  
 \* \- 複合機能提案リスト  
 \*/

import Dexie, { type Table } from 'dexie';  
import { v4 as uuidv4 } from 'uuid';

// \======================================================================  
// 1\. エンティティ (データモデル) 定義  
// \======================================================================

/\*\*  
 \* ノート種別  
 \* \- text: テキストノート  
 \* \- image: 画像ノート (contentはBlob)  
 \* \- audio: 音声ノート (contentはBlob, 将来実装用)  
 \* \- url: URLノート (contentはURL文字列, 要約などを追加可能)  
 \* \- project: プロジェクトノート (思考のコンテナ)  
 \* \- task: タスクノート (チェックボックス付き)  
 \* \- workshop: マルチモーダルなワークショップノート (contentはJSON文字列)  
 \*/  
export type NoteType \= 'text' | 'image' | 'audio' | 'url' | 'project' | 'task' | 'workshop';

/\*\*  
 \* ノートの状態  
 \* \- active: 通常表示されるノート  
 \* \- archived: アーカイブされ、通常の一覧には表示されないノート  
 \*/  
export type NoteStatus \= 'active' | 'archived';

/\*\*  
 \* Workshopノートのコンテント構造  
 \* JSON文字列として content フィールドに保存される  
 \*/  
export interface WorkshopContent {  
  text: string;           // 主要なテキストメモ  
  sketchDataUrl?: string; // スケッチ画像 (Data URL)  
  imageIds?: string\[\];    // 関連付けられた画像ノートのIDリスト  
  modelIds?: string\[\];    // 関連付けられた3DモデルノートのIDリスト (将来用)  
  audioId?: string;       // 関連付けられた音声ノートのID (将来用)  
}

/\*\*  
 \* Note エンティティ: ユーザーの思考の断片  
 \*/  
export interface Note {  
  // \--- 基本情報 \---  
  id: string;               // 主キー (UUID v4)  
  type: NoteType;           // ノート種別 (text, image, audio, url, project, task, workshop)  
  content: string | Blob;   // ノート本体。  
                            // \- text, url: string  
                            // \- image, audio: Blob  
                            // \- workshop: JSON.stringifyされたWorkshopContent  
                            // \- project, task: string (プロジェクト名やタスク内容)  
  createdAt: Date;          // 作成日時 (自動生成)

  // \--- AI関連 \---  
  embedding?: number\[\];       // コンテンツのベクトル埋め込み (クラウド関数で生成)  
  embeddingStatus: 'pending' | 'completed' | 'failed'; // Embedding生成ステータス  
  insightStatus: 'pending' | 'completed' | 'failed'; // 関連性分析ステータス

  // \--- 複合機能用フィールド \---  
  projectId?: string | null;  // 所属するプロジェクトノートのID (FK to Note.id where type='project')  
  location?: string | null;   // ノートが作成された場所 (例: "大阪市", "豊中市")  
  status: NoteStatus;         // ノートの状態 (active | archived)  
  isPinned: boolean;          // ノート一覧でのピン留め状態 (デフォルト: false)  
  tags?: string\[\];            // ACEが提案するタグ (例: \["木工", "アイデア"\])

  // \--- タスクノート用フィールド \---  
  isCompleted?: boolean;      // タスクの完了状態 (type='task' の場合のみ使用)

  // \--- URLノート用フィールド \---  
  summary?: string;           // URLコンテンツの要約 (クラウド関数で生成)

  // \--- プロジェクトノート用フィールド \---  
  // (特定のフィールドは不要、他のノートがprojectIdで紐づく)

  // \--- Workshopノート用フィールド \---  
  // (contentフィールドにWorkshopContentのJSON文字列を格納)

}

/\*\*  
 \* Relation (繋がり) の生成元  
 \* \- ai\_suggestion: AIによる提案  
 \* \- user\_manual: ユーザーによる手動作成  
 \*/  
export type RelationSource \= 'ai\_suggestion' | 'user\_manual';

/\*\*  
 \* Relation (繋がり) へのユーザーフィードバック  
 \* \- useful: 提案が役に立った  
 \* \- harmful: 提案が役に立たなかった / 間違っていた  
 \* \- pending: まだ評価されていない (デフォルト)  
 \*/  
export type RelationFeedback \= 'useful' | 'harmful' | 'pending';

/\*\*  
 \* Relation エンティティ: 2つのノート間の繋がり  
 \*/  
export interface Relation {  
  id: string;               // 主キー (UUID v4)  
  sourceId: string;         // 繋がり元のノートID (FK to Note.id)  
  targetId: string;         // 繋がり先のノートID (FK to Note.id)  
  source: RelationSource;   // 繋がりの生成元 (ai\_suggestion | user\_manual)  
  reasoning?: string;       // AIが提案した理由 / ユーザーが記述した理由  
  feedback: RelationFeedback;// ユーザーからのフィードバック (useful | harmful | pending)  
  createdAt: Date;          // 作成日時 (自動生成)

  // \--- 複合機能用フィールド \---  
  strength?: number;        // AIが判断した繋がりの強度 (0.0 \~ 1.0)  
  userCorrectedReasoning?: string; // ユーザーが修正したReasoning (粒度の高いフィードバック用)  
}

// \======================================================================  
// 2\. Dexie.js データベースクラス定義  
// \======================================================================

/\*\*  
 \* en:gram アプリケーション用 Dexie データベースクラス  
 \*/  
class EngramDB extends Dexie {  
  // テーブルの型定義  
  notes\!: Table\<Note\>;  
  relations\!: Table\<Relation\>;

  constructor() {  
    super('EngramDB'); // データベース名

    // スキーマ定義とバージョン管理  
    // version(1) \-\> version(5) へのマイグレーションを定義  
    this.version(5).stores({  
      // テーブル名: インデックス定義  
      // '++' : Auto-incrementing primary key (Dexieが内部で使用するが、ここではUUIDを明示的に使う)  
      // '&' : Unique index  
      // '\*' : Multi-entry index (for arrays)  
      // '\[A+B\]' : Compound index

      notes: \`  
        id,                зимо❄️ 主キー (UUID)  
        type,              зимо❄️ ノート種別 (text, image, ...)  
        createdAt,         зимо❄️ 作成日時 (降順ソート用)  
        embeddingStatus,   зимо❄️ バックグラウンド処理用  
        insightStatus,     зимо❄️ バックグラウンド処理用  
        \[embeddingStatus+insightStatus\], зимо❄️ バックグラウンド処理キュー用複合インデックス  
        projectId,         зимо❄️ プロジェクト別ノート取得用  
        status,            зимо❄️ アーカイブ機能用 (active | archived)  
        isPinned,          зимо❄️ ピン留めノート取得用 (boolean)  
        location,          зимо❄️ 場所別ノート取得用  
        tags               зимо❄️ タグ検索用 (Multi-entry)  
      \`,  
      relations: \`  
        id,                зимо❄️ 主キー (UUID)  
        sourceId,          зимо❄️ 繋がり元ノート検索用  
        targetId,          зимо❄️ 繋がり先ノート検索用  
        \[sourceId+targetId\], зимо❄️ 特定のペア間の繋がり検索用  
        source,            зимо❄️ 生成元別 (AI/User) 取得用  
        feedback,          зимо❄️ フィードバック別取得用 (useful/harmful/pending)  
        createdAt          зимо❄️ 作成日時 (降順ソート用)  
      \`  
    }).upgrade(tx \=\> {  
      // version(4) からのアップグレードロジック  
      // Noteテーブルに新しいフィールドを追加し、デフォルト値を設定  
      return tx.table('notes').toCollection().modify(note \=\> {  
        note.projectId \= note.projectId \=== undefined ? null : note.projectId;  
        note.location \= note.location \=== undefined ? null : note.location;  
        note.status \= note.status \=== undefined ? 'active' : note.status;  
        note.isPinned \= note.isPinned \=== undefined ? false : note.isPinned;  
        note.tags \= note.tags \=== undefined ? \[\] : note.tags;  
        note.isCompleted \= note.isCompleted \=== undefined ? undefined : note.isCompleted; // taskノート専用  
        note.summary \= note.summary \=== undefined ? undefined : note.summary; // urlノート専用  
      });  
      // Relationテーブルに新しいフィールドを追加  
      return tx.table('relations').toCollection().modify(relation \=\> {  
         relation.strength \= relation.strength \=== undefined ? undefined : relation.strength;  
         relation.userCorrectedReasoning \= relation.userCorrectedReasoning \=== undefined ? undefined : relation.userCorrectedReasoning;  
      });  
    });

  }

  // \======================================================================  
  // 3\. ヘルパーメソッド (データアクセス用)  
  // \======================================================================

  /\*\*  
   \* 指定されたオフセットとリミットでノートを取得 (作成日時降順)  
   \* @param offset \- 取得開始位置  
   \* @param limit \- 取得件数  
   \* @param status \- 取得するノートの状態 (デフォルト: 'active')  
   \* @param projectId \- フィルタリングするプロジェクトID (オプション)  
   \*/  
  async getPaginatedNotes(  
    offset: number,  
    limit: number,  
    status: NoteStatus \= 'active',  
    projectId?: string  
  ): Promise\<Note\[\]\> {  
    let query \= this.notes.where('status').equals(status);  
    if (projectId) {  
      query \= query.and(note \=\> note.projectId \=== projectId);  
    }  
    return query.orderBy('createdAt').reverse().offset(offset).limit(limit).toArray();  
  }

  /\*\*  
   \* 指定されたノートIDに関連するノートの総数を取得  
   \* @param status \- カウントするノートの状態  
   \* @param projectId \- フィルタリングするプロジェクトID (オプション)  
   \*/  
  async countNotes(status: NoteStatus \= 'active', projectId?: string): Promise\<number\> {  
    let query \= this.notes.where('status').equals(status);  
    if (projectId) {  
      query \= query.and(note \=\> note.projectId \=== projectId);  
    }  
    return query.count();  
  }

  /\*\*  
   \* 指定されたオフセットとリミットで関連性を取得 (作成日時降順)  
   \* @param offset \- 取得開始位置  
   \* @param limit \- 取得件数  
   \*/  
  async getPaginatedRelations(offset: number, limit: number): Promise\<Relation\[\]\> {  
    return this.relations.orderBy('createdAt').reverse().offset(offset).limit(limit).toArray();  
  }

    /\*\*  
   \* 指定されたノートIDに関連する関連性の総数を取得  
   \* @param noteId \- 対象のノートID  
   \*/  
  async countRelationsForNote(noteId: string): Promise\<number\> {  
    return this.relations.where('sourceId').equals(noteId).or('targetId').equals(noteId).count();  
  }

  /\*\*  
   \* 指定されたIDの関連性を削除する  
   \* @param id \- 削除する関連性のID  
   \*/  
  async deleteRelation(id: string): Promise\<void\> {  
    await this.relations.delete(id);  
  }

  /\*\*  
   \* 指定されたIDの関連性のフィードバックを更新する  
   \* @param id \- 更新する関連性のID  
   \* @param feedback \- 新しいフィードバック状態  
   \* @param userCorrectedReasoning \- (オプション) ユーザーが修正したReasoning  
   \*/  
  async updateRelationFeedback(  
    id: string,  
    feedback: RelationFeedback,  
    userCorrectedReasoning?: string  
  ): Promise\<void\> {  
    const updateData: Partial\<Relation\> \= { feedback };  
    if (userCorrectedReasoning \!== undefined) {  
      updateData.userCorrectedReasoning \= userCorrectedReasoning;  
    }  
    await this.relations.update(id, updateData);  
  }

  /\*\*  
   \* 指定されたIDのノートの状態を更新する (アーカイブ/アクティブ化)  
   \* @param id \- 更新するノートのID  
   \* @param status \- 新しい状態  
   \*/  
  async updateNoteStatus(id: string, status: NoteStatus): Promise\<void\> {  
      await this.notes.update(id, { status });  
  }

   /\*\*  
   \* 指定されたIDのノートのピン留め状態を更新する  
   \* @param id \- 更新するノートのID  
   \* @param isPinned \- 新しいピン留め状態  
   \*/  
  async updateNotePinnedStatus(id: string, isPinned: boolean): Promise\<void\> {  
    await this.notes.update(id, { isPinned });  
  }

   /\*\*  
   \* 指定されたIDのタスクノートの完了状態を更新する  
   \* @param id \- 更新するタスクノートのID  
   \* @param isCompleted \- 新しい完了状態  
   \*/  
    async updateTaskCompletion(id: string, isCompleted: boolean): Promise\<void\> {  
        // 対象がタスクノートかどうかのチェックは呼び出し元で行う想定  
        await this.notes.update(id, { isCompleted });  
    }  
}

// \======================================================================  
// 4\. Dexie Hooks の設定  
// \======================================================================

// シングルトンインスタンスを作成  
const db \= new EngramDB();

/\*\*  
 \* Note テーブルへの 'creating' フック:  
 \* \- 新規ノート作成時に自動で UUID v4 の ID を設定する。  
 \* \- 新規ノート作成時に自動で現在日時を createdAt に設定する。  
 \* \- status, isPinned のデフォルト値を設定する。  
 \* \- embeddingStatus, insightStatus の初期値を 'pending' に設定する。  
 \*/  
db.notes.hook('creating', (primKey, obj: Note) \=\> {  
  // IDと作成日時が未設定の場合のみ自動設定 (Upsert等で既に存在する可能性も考慮)  
  if (obj.id \=== undefined) obj.id \= uuidv4();  
  if (obj.createdAt \=== undefined) obj.createdAt \= new Date();  
  if (obj.status \=== undefined) obj.status \= 'active';  
  if (obj.isPinned \=== undefined) obj.isPinned \= false;  
  if (obj.embeddingStatus \=== undefined) obj.embeddingStatus \= 'pending';  
  if (obj.insightStatus \=== undefined) obj.insightStatus \= 'pending';  
  // projectId, location, tags など他のオプションフィールドは  
  // 必要に応じて呼び出し元で初期値を設定する想定  
});

/\*\*  
 \* Relation テーブルへの 'creating' フック:  
 \* \- 新規関連性作成時に自動で UUID v4 の ID を設定する。  
 \* \- 新規関連性作成時に自動で現在日時を createdAt に設定する。  
 \* \- feedback のデフォルト値を 'pending' に設定する。  
 \*/  
db.relations.hook('creating', (primKey, obj: Relation) \=\> {  
  if (obj.id \=== undefined) obj.id \= uuidv4();  
  if (obj.createdAt \=== undefined) obj.createdAt \= new Date();  
  if (obj.feedback \=== undefined) obj.feedback \= 'pending';  
});

// \======================================================================  
// 5\. エクスポート  
// \======================================================================

export default db; // シングルトンインスタンスをエクスポート

// 開発モード時に window オブジェクトに db を公開 (デバッグ用)  
if (import.meta.env.DEV) {  
  (window as any).db \= db;  
}

