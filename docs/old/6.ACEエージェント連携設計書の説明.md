# **【資料6/8】ACEエージェント連携設計書の説明**

この資料 (engram\_ace\_integration\_design.md) は、en:gram フロントエンド (App.tsx) が、自己改善機能を持つ ACE (Agentic Context Engineering) バックエンドとどのように通信し、連携するかの詳細を定義します。

**主な内容:**

1. **ACEエージェント呼び出し (callAceFlow):**  
   * ユーザーが MainPage で質問を入力し、「Get Insights」ボタンを押した際の処理フローを定義しています。  
   * Firebase Functions で定義された aceFlow 関数を呼び出す際の **リクエストペイロード** (thread\_id, query) を指定しています。  
   * バックエンドからの **レスポンス** (response, playbookSize) を受け取り、応答本文 (response) から **正規表現** を用いて、Markdown 部分とプレイブックへのフィードバック情報 (\<PLAYBOOK\_FEEDBACK\>) を分離・パースする具体的な手順を記述しています。  
   * 処理中フラグ (isAceWorking)、結果表示 (aceResult)、エラー表示 (aceError) の **状態管理** 方法を定義しています。  
2. **参照ノート取得 (handleFeedbackClick):**  
   * ACE の応答内にある「Ref」ボタンがクリックされた際に、その根拠となったノートの内容を取得・表示するための処理フローです。  
   * **ローカルファースト戦略:** まずクライアント内の IndexedDB (db.ts) を検索し、ノートが見つからなければ Firebase Functions (getPlaybookNote) を呼び出してクラウド上のプレイブックから取得を試みる、という **段階的なデータ取得** ロジックを定義しています。  
   * 画像ノートの場合の **Blob URL の生成・管理** (URL.createObjectURL, URL.revokeObjectURL) と、モーダル表示の状態管理 (modalNote) についても記述しています。  
3. **データ構造 (API連携):**  
   * フロントエンドとバックエンド関数 (aceFlow, getPlaybookNote) 間で交換されるデータの **具体的な JSON 形式** (リクエストとレスポンス) を明記しています。これは、バックエンド側の【資料7/8】API設計書と整合性を取る必要があります。  
4. **エラーハンドリング:**  
   * 各関数呼び出しにおける **try...catch** の使用箇所と、エラー発生時の挙動（コンソールへのログ出力、エラー状態 (aceError) の更新）を定義しています。

LLMへの実装指示:  
この設計書に基づき、src/App.tsx ファイル内に callAceFlow, handleFeedbackClick, closeNoteModal 関数を実装し、関連する状態変数 (isAceWorking, aceResult, aceError, modalNote) を適切に管理してください。また、AceResult 型と ModalNote 型を定義してください。Firebase Functions の呼び出しには firebase.ts からインポートした関数 (aceFlow, getPlaybookNote) を使用してください。

# **en:gram ACEエージェント連携設計書**

バージョン: 1.0

作成日: 2025-10-29

**目的:**

* en:gram フロントエンド (App.tsx) と ACE (Agentic Context Engineering) バックエンド (Firebase Cloud Functions) 間の連携方法を詳細に定義する。  
* ACEエージェント呼び出し (callAceFlow) と参照ノート取得 (handleFeedbackClick) のロジック、データ構造、エラーハンドリングを規定する。  
* AIエージェント (LLM) がこの仕様書を読み込み、App.tsx 内のACE連携関連の関数を実装できるようにする。

**参照資料:**

* 【資料1/8】システム概要とアーキテクチャ設計書  
* 【資料2/8】データベース設計書 (engram\_database\_design.ts)  
* 【資料3/8】フロントエンド基本設計書  
* 【資料4/8】主要UIコンポーネント詳細設計書  
* 【資料5/8】クライアントサイドAIロジック設計書  
* 【資料7/8】バックエンドAPI設計書 (次作成予定)  
* firebase.ts, ACEアルゴリズムJavaScript実装ガイド.md

## **1\. ACEエージェント呼び出し (src/App.tsx 内)**

* **目的:** ユーザーが MainPage.tsx で入力したクエリ (aceQuery) を基に、ACEバックエンドを呼び出し、分析結果を取得して表示する。  
* **トリガー:** MainPage.tsx の「Get Insights」ボタンクリック → handleCallAceFlow (in MainPage.tsx) → callAceFlow (in App.tsx)。  
* **主要関数:** callAceFlow(): Promise\<void\>  
* **状態管理:**  
  1. isAceWorking (boolean): ACE処理中を示すフラグ。処理開始時に true、終了時に false に設定。UIスピナー (InsightBloomAnimation) の表示制御に使用。  
  2. aceResult (AceResult | null): ACEからの正常な応答を保持。AceResult 型は { playbookSize: number; markdown: string; feedback: { useful: string\[\], harmful: string\[\] } | null; } とする。  
  3. aceError (string | null): ACE呼び出し中に発生したエラーメッセージを保持。  
  4. aceQuery (string): MainPage.tsx から渡されるユーザー入力クエリ。  
* **アルゴリズム:**  
  1. aceQuery が空文字列の場合は何もしない。  
  2. setIsAceWorking(true) を呼び出す。  
  3. setAceResult(null) と setAceError(null) を呼び出し、前回の結果/エラーをクリアする。  
  4. try ブロック:  
     * **リクエストデータ準備:**  
       * thread\_id: 固定の文字列 (例: 'ace-main-thread-1') またはユーザー/セッションごとに一意なIDを使用する。永続的な学習のため、thread\_id は固定または管理可能にする必要がある。（【資料7/8】で詳細定義）  
       * query: aceQuery の値。  
       * ペイロードオブジェクト: { thread\_id: string, query: string }  
     * **クラウド関数呼び出し:** aceFlow(payload) を呼び出す (firebase.ts からインポート)。  
     * **レスポンス処理:**  
       * 応答 (result.data) を { response: string, playbookSize: number } 型として受け取る。  
       * 応答文字列 (rawResponse \= data.response) から \<PLAYBOOK\_FEEDBACK\> タグを正規表現 (/\<PLAYBOOK\_FEEDBACK\>(\[\\s\\S\]\*?)\<\\/PLAYBOOK\_FEEDBACK\>/) で検索する。  
       * markdownContent: マッチしなかった場合は rawResponse 全体。マッチした場合は、タグ部分を除去した残りの文字列 (rawResponse.replace(...))。  
       * feedbackData: マッチしなかった場合は null。マッチした場合は、タグ内のJSON文字列 (match\[1\]) を JSON.parse() する。パース失敗時はコンソールにエラーを出力し null とする。  
       * setAceResult({ playbookSize: data.playbookSize, markdown: markdownContent, feedback: feedbackData }) を呼び出して状態を更新する。  
  5. catch ブロック:  
     * エラー (error) を捕捉する。  
     * エラーをコンソールに出力する (console.error("Error calling ACE server: ", error))。  
     * setAceError(\\Error: ${(error as Error).message}\`)\` を呼び出してエラー状態を更新する。  
  6. finally ブロック:  
     * setIsAceWorking(false) を呼び出す。  
* **LLMへの実装指示:** 上記アルゴリズムに基づき、App.tsx 内に callAceFlow 関数を実装してください。aceFlow 関数は firebase.ts からインポートしてください。AceResult 型を定義してください。正規表現によるフィードバックデータの抽出とパース処理を実装してください。状態変数 (isAceWorking, aceResult, aceError) を適切に更新してください。

## **2\. 参照ノート取得 (src/App.tsx 内)**

* **目的:** ACEの応答に含まれる参照ノートID (Ref ボタン) に対応するノートの内容を取得し、モーダルウィンドウで表示する。ローカルDBを優先し、見つからない場合はクラウドのプレイブックから取得する（ローカルファースト戦略）。  
* **トリガー:** MainPage.tsx の参照ノートボタン (.feedback-note-button) クリック → handleFeedbackClick(noteId: string) (in App.tsx)。  
* **主要関数:** handleFeedbackClick(noteId: string): Promise\<void\>  
* **状態管理:**  
  * modalNote (ModalNote | null): モーダルで表示するノート情報 ({ note: Note; imageUrl: string | null; }) を保持。表示時はオブジェクトを、非表示時は null を設定。  
* **アルゴリズム:**  
  * 現在モーダルが表示されていれば (modalNote が null でなければ)、closeNoteModal() を呼び出す（重複表示防止）。  
  * **ローカルDB検索:**  
    * まず、useLiveQuery で取得済みの allNotes 配列から noteId でノートを検索する (noteFromAll)。  
    * 見つからない場合、await db.notes.get(noteId) を呼び出して IndexedDB から直接取得を試みる (noteFromDb)。  
    * ローカルで見つかった場合 (note \= noteFromAll || noteFromDb)、ステップ4に進む。  
  * **クラウドフォールバック:**  
    * ローカルで見つからなかった場合、「Note ... not found locally. Fetching from cloud playbook...」とログ出力する。  
    * try ブロック:  
      * await getPlaybookNote({ noteId: noteId }) を呼び出す (firebase.ts からインポート)。  
      * 応答 (result.data) を { data: Note } 型として受け取り、note \= result.data.data とする。  
    * catch ブロック:  
      * エラーをコンソールに出力する (console.error(\\Failed to fetch playbook note ${noteId}:\`, error)\`)。  
      * note は null のままとなる。  
  * **ノートが見つからない場合:**  
    * ステップ3の後でも note が null の場合、「Feedback note ... not found in DB or Cloud.」とエラーログを出力し、処理を終了する。  
  * **画像URL処理:**  
    * note.type が 'image' の場合、表示用の imageUrl (tempUrl) を決定する:  
      * imageUrls state (キャッシュ済みBlob URL) に note.id が存在すれば、そのURLを使用する。  
      * 存在せず、note.content が Blob インスタンスであれば、URL.createObjectURL(note.content) を呼び出して一時URLを生成する。  
      * 上記以外で、note.content が http で始まる文字列（クラウドから取得したURLなど）であれば、その文字列をそのままURLとして使用する。  
      * それ以外の場合は null とする。  
  * **モーダル表示:**  
    * setModalNote({ note: note, imageUrl: tempUrl }) を呼び出してモーダル表示状態を更新する。  
* **補助関数:** closeNoteModal(): void  
  * modalNote が存在し、かつ imageUrl がキャッシュ (imageUrls) にない一時URLだった場合、URL.revokeObjectURL(modalNote.imageUrl) を呼び出してメモリを解放する。  
  * setModalNote(null) を呼び出してモーダルを閉じる。  
* **LLMへの実装指示:** 上記アルゴリズムに基づき、App.tsx 内に handleFeedbackClick 関数と closeNoteModal 関数を実装してください。getPlaybookNote 関数は firebase.ts からインポートしてください。db, allNotes, imageUrls, modalNote, setModalNote などの状態やDBインスタンスを適切に使用してください。ModalNote 型を定義してください。

## **3\. データ構造 (API連携)**

* **aceFlow 関数 (呼び出し)**  
  * **リクエストペイロード:** { thread\_id: string, query: string }  
  * **レスポンスデータ:** { response: string, playbookSize: number } (※ response 文字列内に \<PLAYBOOK\_FEEDBACK\> タグが含まれる可能性がある)  
* **getPlaybookNote 関数 (呼び出し)**  
  * **リクエストペイロード:** { noteId: string }  
  * **レスポンスデータ:** { data: Note } (※ Note 型は db.ts で定義されたものと互換性がある必要がある)

## **4\. エラーハンドリング**

* **callAceFlow:**  
  * aceFlow の呼び出しは try...catch で囲む。  
  * エラー発生時、コンソールにエラーを出力し、aceError state にエラーメッセージを設定する。これにより MainPage.tsx でエラーが表示される。  
  * finally ブロックで isAceWorking を false に戻す。  
* **handleFeedbackClick:**  
  * getPlaybookNote の呼び出しは try...catch で囲む。  
  * クラウドからの取得に失敗した場合、コンソールにエラーを出力するが、UI上での明示的なエラー表示は行わない（モーダルが開かないだけ）。  
  * ローカルDBでもクラウドでもノートが見つからなかった場合、コンソールにエラーを出力する。