# **【資料7/8】バックエンドAPI設計書の説明**

この資料 (engram\_backend\_api\_design.ts) は、en:gram アプリケーションのバックエンドとして機能する Firebase Cloud Functions の各 API について、その仕様を詳細に定義します。

**主な内容:**

1. **共通設定:**  
   * デプロイ先のリージョン (REGION)、デフォルトのランタイムオプション (RUNTIME\_OPTIONS)、Secret Manager を使った API キー管理 (GEMINI\_API\_KEY\_SECRET) など、すべての関数に共通する設定を定義しています。  
2. **Note 型スキーマ:**  
   * クライアント (db.ts) とのデータ互換性を保ちつつ、バックエンドでのバリデーションに使用するための Note 型の Zod スキーマ (BackendNoteSchema) を定義しています。画像や音声は Base64 文字列として扱われることを想定しています。  
3. 各 Cloud Function の仕様:  
   以下の関数について、それぞれの詳細仕様を Spec オブジェクトとして定義しています。  
   * **findConnections:** ハイブリッド AI のクラウドフォールバック用。onCall トリガー。Gemini Flash を使用。入力・出力は Zod スキーマで定義され、クライアントの期待する形式と一致させます。  
   * **embedNote:** ノートの Embedding 生成用。現状維持の onRequest トリガー。Multimodal Embedding モデルを使用。CORS ヘッダーの手動設定が必要です。  
   * **aceFlow:** ACE エージェント (LangGraph) 実行用。onCall トリガー。長いタイムアウトと多めのメモリを設定。Firestore 上のプレイブックを読み書きします。複合機能のツール連携もこの関数内で実装されます。  
   * **getPlaybookNote:** ACE プレイブックから特定のノートを取得する用。onCall トリガー。Firestore からデータを取得し、クライアントが扱える形式に変換します。  
   * **summarizeUrl:** URL の内容を要約する用 (複合機能)。onCall トリガー。Web ページの取得と本文抽出、Gemini による要約を行います。  
4. **各 Spec オブジェクトの内容:**  
   * functionName: 関数名。  
   * trigger: 関数のトリガータイプ (onCall または onRequest)。  
   * description: 関数の目的。  
   * region, runtime, secrets: デプロイ設定。  
   * inputSchema, outputSchema: Zod を用いた入力・出力データのスキーマ定義。  
   * coreLogic: 関数の主要な処理内容のステップバイステップ記述。Genkit や LangGraph の使用箇所も示唆。  
   * authentication: 認証が必要かどうか。  
   * corsHandling: (onRequest の場合) CORS の扱い。  
   * errorHandling: エラー発生時の挙動。

LLMへの実装指示:  
この設計書に基づき、functions/src/index.ts ファイルに上記の各 Firebase Cloud Functions を実装してください。Genkit や LangGraph の具体的な実装は、それぞれのライブラリのドキュメントや【資料4/8】(ACE実装部分) を参照しつつ、この設計書で定義された I/O スキーマと Core Logic に従ってください。  
import { z } from 'zod'; // Zodをスキーマ定義とバリデーションに使用

// \--- 共通設定 \---

/\*\*  
 \* リージョン: アプリケーションの主要なユーザーが存在するリージョンを選択  
 \* 例: 'asia-northeast1' (東京)  
 \*/  
const REGION \= 'asia-northeast1';

/\*\*  
 \* ランタイム: Node.js 20 を推奨  
 \*/  
const RUNTIME\_OPTIONS \= {  
  timeoutSeconds: 60, // デフォルトタイムアウト (必要に応じて関数ごとに上書き)  
  memory: '256MB' as const, // デフォルトメモリ (必要に応じて関数ごとに上書き)  
};

/\*\*  
 \* シークレット管理: Gemini API キーなどの機密情報は Secret Manager を使用  
 \* 'GEMINI\_API\_KEY' という名前のシークレットが Secret Manager に存在することを前提とする  
 \*/  
const GEMINI\_API\_KEY\_SECRET \= 'GEMINI\_API\_KEY';

// \--- Note 型 (クライアントと共通、バリデーション用) \---  
// 【資料2/8】データベース設計書に基づき、より厳密な Zod スキーマを定義  
// 注意: Blob は直接 JSON で転送できないため、画像/音声は Base64 文字列として扱う

const NoteTypeSchema \= z.enum(\['text', 'image', 'audio', 'url', 'project', 'task', 'workshop'\]); // 拡張含む

const BaseNoteSchema \= z.object({  
  id: z.string().uuid(),  
  type: NoteTypeSchema,  
  content: z.unknown(), // タイプによって異なるため、後で refine  
  createdAt: z.string().datetime(), // ISO 8601 string  
  embeddingStatus: z.enum(\['pending', 'completed', 'failed'\]),  
  insightStatus: z.enum(\['pending', 'completed', 'failed'\]),  
  // 追加フィールド (複合機能より)  
  projectId: z.string().uuid().nullable().optional(),  
  location: z.string().nullable().optional(),  
  tags: z.array(z.string()).optional(),  
  isPinned: z.boolean().optional(),  
  status: z.enum(\['active', 'archived'\]).optional(),  
  isCompleted: z.boolean().optional(), // task type 用  
}).refine(data \=\> {  
  // content の型を type に応じて検証  
  if (data.type \=== 'text' || data.type \=== 'url' || data.type \=== 'location') {  
    return typeof data.content \=== 'string';  
  }  
  if (data.type \=== 'image' || data.type \=== 'audio') {  
    // Base64 文字列を想定 (または URL)  
    return typeof data.content \=== 'string';  
  }  
  // 他のタイプ (project, task, workshop) は object や null を許容するなど、  
  // 【資料2/8】に基づき詳細な検証を追加  
  if (data.type \=== 'task') return typeof data.content \=== 'string'; // タスク名など  
  // workshop は JSON 文字列 or オブジェクトを想定  
  if (data.type \=== 'workshop') return typeof data.content \=== 'object' || typeof data.content \=== 'string';  
  if (data.type \=== 'project') return typeof data.content \=== 'string'; // プロジェクト概要など  
  return false;  
}, {  
  message: "Content type does not match note type",  
  path: \["content"\],  
});

// バックエンドで扱う Note 型 (content は主に string か object)  
// embedding は number\[\] だが、API I/O では直接扱わないことが多い  
const BackendNoteSchema \= BaseNoteSchema.extend({}); // 必要に応じて content 型を上書き

// \--- Firebase Cloud Functions 仕様 \---

// 1\. findConnections (ハイブリッドAIフォールバック用)  
// \=======================================================  
export const FindConnectionsSpec \= {  
  functionName: 'findConnections',  
  trigger: 'onCall' as const, // HTTPS Callable Function  
  description: '新規ノートと文脈ノートを受け取り、AI (Gemini 2.5 Flash Lite) を用いてそれらの間の繋がりを最大3件提案する。オンデバイスAIが利用不可の場合のフォールバック。※モデルは設定で変更可能',  
  region: REGION,  
  runtime: RUNTIME\_OPTIONS,  
  secrets: \[GEMINI\_API\_KEY\_SECRET\],  
  inputSchema: z.object({  
    newNote: z.object({ // Base64エンコードされた画像コンテンツを含む  
      id: z.string().uuid(),  
      type: NoteTypeSchema,  
      content: z.string(), // テキストまたは Base64 画像文字列  
    }),  
    contextNotes: z.array(z.object({  
      id: z.string().uuid(),  
      type: NoteTypeSchema,  
      content: z.string(), // テキストまたは Base64 画像文字列  
    })).max(10), // コンテキストノートは最大10件  
  }),  
  outputSchema: z.array(z.object({ // クライアントの JSON Schema と一致させる  
    targetNoteId: z.string().uuid(),  
    reasoning: z.string(),  
  })),  
  coreLogic: \`  
    1\. Genkit フローとして定義する。  
    2\. 入力データを Zod スキーマでバリデーションする。  
    3\. Gemini API キーを Secret Manager から取得する。  
    4\. Google AI (Gemini 2.5 Flash Lite モデル) を初期化する。※モデルは設定で変更可能  
    5\. クライアントサイドと同じプロンプト ('textPrompt') を使用し、新規ノートと文脈ノートをインプットとして Gemini Flash モデルを呼び出す。画像ノートの場合は、Base64 文字列を適切に処理する (マルチモーダル呼び出し)。  
    6\. モデルからの応答 (JSON 文字列) をパースし、Zod スキーマでバリデーションする。  
    7\. 結果の配列を返す。  
  \`,  
  authentication: true, // 認証済みユーザーのみ許可 (context.auth \!= null)  
  errorHandling: '標準的な onCall エラー (internal, invalid-argument など) を返す。',  
};

// 2\. embedNote (Embedding 生成用)  
// \=====================================  
export const EmbedNoteSpec \= {  
  functionName: 'embedNote',  
  trigger: 'onRequest' as const, // HTTP Request Function (現状維持、CORS手動設定)  
  description: 'ノートのコンテンツ (テキストまたは画像) を受け取り、Google の Multimodal Embedding モデルを用いてベクトル埋め込みを生成して返す。',  
  region: REGION,  
  runtime: RUNTIME\_OPTIONS,  
  secrets: \[GEMINI\_API\_KEY\_SECRET\], // Embedding モデル呼び出しに必要  
  inputSchema: z.object({ // POST リクエストの body を想定  
    data: z.object({  
      type: z.enum(\['text', 'image'\]), // 他のタイプも必要に応じて追加  
      content: z.string(), // テキストまたは Base64 画像文字列  
    }),  
  }),  
  outputSchema: z.object({ // 成功時のレスポンスボディ  
    data: z.array(z.number()), // Embedding ベクトル  
  }),  
  coreLogic: \`  
    1\. HTTP POST リクエストの body をパースし、Zod スキーマでバリデーションする。  
    2\. CORS ヘッダーを設定する (OPTIONS リクエストにも対応)。許可するオリジンは環境変数などで管理する (例: VITE\_APP\_URL)。  
    3\. Gemini API キーを Secret Manager から取得する。  
    4\. Google AI ('multimodalembedding' モデル) を初期化する。  
    5\. 入力タイプに応じて、テキストまたは Base64 画像データをモデルに渡し、埋め込みを生成する。  
    6\. 生成されたベクトルをレスポンスボディとして返す ({ data: embeddingVector })。  
  \`,  
  authentication: false, // 公開API (必要なら API Gateway や Auth ヘッダーで保護)  
  corsHandling: '手動で \`Access-Control-Allow-Origin\` などのヘッダーを設定する必要がある。',  
  errorHandling: 'バリデーションエラー時は 400 Bad Request、モデルエラー時は 500 Internal Server Error などを返す。',  
  // 注意: spec.md の提案通り onCall に移行する場合、CORS は不要になり、認証が必須となる。  
};

// 3\. aceFlow (ACE エージェント実行用)  
// \======================================  
export const AceFlowSpec \= {  
  functionName: 'aceFlow',  
  trigger: 'onCall' as const, // HTTPS Callable Function  
  description: '指定されたスレッドIDとクエリに基づき、LangGraph で構築された ACE エージェントの自己改善ループを実行する。Firestore 上のプレイブックを読み書きする。',  
  region: REGION,  
  runtime: {  
    ...RUNTIME\_OPTIONS,  
    timeoutSeconds: 300, // spec.md に基づきタイムアウトを延長  
    memory: '1GB' as const, // LangGraph/LLM 実行のためメモリを増量  
  },  
  secrets: \[GEMINI\_API\_KEY\_SECRET\], // ACE 内の LLM (Generator/Reflector) 呼び出しに必要  
  inputSchema: z.object({  
    thread\_id: z.string().min(1), // LangGraph の Checkpointer で状態を管理するためのID  
    query: z.string().min(1),  
  }),  
  outputSchema: z.object({  
    response: z.string(), // Generator の最終応答 (\<PLAYBOOK\_FEEDBACK\> を含む可能性あり)  
    playbookSize: z.number().int().nonnegative(), // 更新後のプレイブックのエントリ数  
  }),  
  coreLogic: \`  
    1\. 入力データを Zod スキーマでバリデーションする。  
    2\. Firebase Admin SDK を初期化する (Firestore アクセス用)。  
    3\. Gemini API キーを Secret Manager から取得する。  
    4\. LangGraph の ACE アプリケーションを初期化する。  
       \- Generator, Reflector に Gemini モデル (例: gemini-2.5-flash-lite, gemini-pro) を設定。  
       \- Curator に Embedding モデル (例: @xenova/transformers) を設定 (または Cloud Function内で API 呼び出し)。  
       \- Firestore Checkpointer を設定し、'ace\_playbooks/{thread\_id}/state' のようなパスで状態を永続化する。  
    5\. LangGraph アプリケーションを \`app.invoke()\` で実行する。入力として \`{ current\_query: query, messages: \[new HumanMessage(query)\] }\` を与え、\`config: { configurable: { thread\_id } }\` を渡す。  
    6\. 実行結果の最終状態 (\`finalState\`) から、最後のメッセージ (\`finalState.messages.slice(-1)\`) と更新後のプレイブックサイズ (\`finalState.playbook.length\`) を取得する。  
    7\. 結果を Zod スキーマでバリデーションし、返す。  
    // ACE ツール連携 (複合機能2) の実装:  
    8\. Generator ノード内で、クエリに応じて Google Search API や WoodSpeciesAPI (ダミーまたは実際のAPI) を呼び出す LangChain Tool/Genkit Tool を定義・使用する。  
    9\. ツール呼び出しの結果も軌跡 (trajectory) に含め、Reflector/Curator が学習できるようにする。  
  \`,  
  authentication: true, // 認証済みユーザーのみ許可  
  errorHandling: 'LangGraph 実行時エラーや Firestore アクセスエラーを捕捉し、標準的な onCall エラーを返す。',  
};

// 4\. getPlaybookNote (参照ノート取得用)  
// \======================================  
export const GetPlaybookNoteSpec \= {  
  functionName: 'getPlaybookNote',  
  trigger: 'onCall' as const, // HTTPS Callable Function  
  description: '指定されたノートIDに基づき、ACEエージェントが Firestore に保存しているプレイブック（ノートデータ）から該当ノートを取得して返す。',  
  region: REGION,  
  runtime: RUNTIME\_OPTIONS,  
  inputSchema: z.object({  
    noteId: z.string().uuid(),  
  }),  
  // outputSchema は { data: Note } 型だが、Note 型はクライアントと完全に一致させる必要がある。  
  // Firestore から取得したデータ (Timestamp含む) をクライアントが期待する形式 (Date or ISO string) に変換する。  
  outputSchema: z.object({  
     data: BackendNoteSchema, // Firestore から取得したノートデータ  
  }),  
  coreLogic: \`  
    1\. 入力データを Zod スキーマでバリデーションする。  
    2\. Firebase Admin SDK を初期化する。  
    3\. Firestore の 'ace\_playbooks/notes/{noteId}' (仮のパス、ACE実装に依存) のようなパスからドキュメントを取得する。  
    4\. ドキュメントが見つからない場合は 'not-found' エラーを返す。  
    5\. Firestore の Timestamp 型をクライアントが扱える ISO 8601 文字列に変換する。  
    6\. 取得したノートデータを { data: noteData } の形式で返す。  
  \`,  
  authentication: true, // 認証済みユーザーのみ許可  
  errorHandling: 'Firestore アクセスエラーやドキュメントが見つからない場合に適切なエラーコードを返す。',  
};

// 5\. summarizeUrl (URL 要約用 \- 複合機能で必要)  
// \============================================  
export const SummarizeUrlSpec \= {  
  functionName: 'summarizeUrl',  
  trigger: 'onCall' as const, // HTTPS Callable Function  
  description: '指定された URL のコンテンツを取得し、AI (Gemini 2.5 Flash Lite) を用いて要約する。※モデルは設定で変更可能',  
  region: REGION,  
  runtime: { ...RUNTIME\_OPTIONS, timeoutSeconds: 120 }, // Web ページ取得に時間がかかる可能性  
  secrets: \[GEMINI\_API\_KEY\_SECRET\],  
  inputSchema: z.object({  
    url: z.string().url(),  
  }),  
  outputSchema: z.object({  
    summary: z.string(),  
  }),  
  coreLogic: \`  
    1\. Genkit フローとして定義する。  
    2\. 入力データを Zod スキーマでバリデーションする。  
    3\. 指定された URL の HTML コンテンツを fetch API などで取得する。  
    4\. HTML から本文テキストを抽出する (例: Cheerio ライブラリを使用)。  
    5\. Gemini API キーを取得する。  
    6\. Google AI (Gemini 2.5 Flash Lite または Pro モデル) を初期化する。※モデルは設定で変更可能  
    7\. 抽出した本文テキストを要約するようにモデルに指示するプロンプトを作成する。  
    8\. モデルを呼び出し、要約結果を取得する。  
    9\. 要約結果を Zod スキーマでバリデーションし、返す。  
  \`,  
  authentication: true, // 認証済みユーザーのみ許可  
  errorHandling: 'URL 取得失敗、本文抽出失敗、モデルエラーなどを捕捉し、適切なエラーを返す。',  
};

// \--- LLMへの実装指示 \---  
/\*\*  
 \* 上記の各 Spec オブジェクトに基づき、Firebase Cloud Functions のコード (\`functions/src/index.ts\`) を実装してください。  
 \* 各関数は指定されたトリガータイプ (\`onCall\` または \`onRequest\`) で定義してください。  
 \* Zod を使用して入力データのバリデーションを行ってください。  
 \* Genkit を使用できる場合は、\`findConnections\` と \`summarizeUrl\` を Genkit フローとして実装してください。  
 \* \`aceFlow\` は LangGraph アプリケーションを呼び出すロジックを実装してください (LangGraph のコード自体は別ファイル/ディレクトリ管理を想定)。  
 \* \`embedNote\` は HTTP リクエストを処理し、手動で CORS ヘッダーを設定してください。  
 \* \`getPlaybookNote\` は Firestore からデータを取得・変換してください。  
 \* Secret Manager から API キーを安全に取得してください。  
 \* 適切な認証チェックとエラーハンドリングを実装してください。  
 \*/

