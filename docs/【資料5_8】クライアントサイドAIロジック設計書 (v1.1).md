# **【資料5/8】クライアントサイドAIロジック設計書 (v1.1)**

## **1\. 概要**

本資料は、en:gram のクライアントサイド（主に App.tsx と similarity.ts）で実行されるAI関連ロジックを詳細に定義する。これには、バックグラウンドでのEmbeddingおよびInsight（自動接続）処理、オンデバイスAIとクラウドフォールバックによるハイブリッドAIエンジンが含まれる。

**v1.1の主な変更点:**

* AIエージェントの名称を「ACEエージェント」から「**Engrammer**」に変更。  
* バックグラウンドワーカーの責務を明確化。Insightワーカーは「自動接続 (getInsightSuggestions)」専用とし、「Engrammer（engrammerFlow）」の呼び出しはユーザー起点（MainPage.tsx\[cite: MainPage.tsx\]）\[cite: engram\_frontend\_basic\_design\_v1.1.md\]と分離する。  
* ハイブリッドAI (getInsightSuggestions\[cite: App.tsx\]) のプロンプトを、LangChain 1.0 \[cite: LangChain/LangGraph 1.0 詳細調査計画\] の create\_agent \[cite: LangChain/LangGraph 1.0 詳細調査計画\] の概念（改善案\#5）に合わせ、バックエンド (findConnectionsCloud\[cite: firebase.ts\]) との一貫性を高めるよう指示する。  
* 【資料2/8】\[cite: engram\_database\_design\_v1.1.md\]で追加された新しいNoteType\[cite: engram\_database\_design\_v1.1.md\]（sketch\_image, 3d\_modelなど）に対応するロジックのフックを定義する。

## **2\. バックグラウンドワーカー (App.tsx 内の useEffect フック)**

App.tsx\[cite: App.tsx\]は useLiveQuery\[cite: App.tsx\] を使用し、DB\[cite: db.ts\]のステータス変更を監視する2つの独立したワーカーを実装する。

### **2.1. Embeddingワーカー (useEmbeddingWorker)**

* **トリガー:** useLiveQuery\[cite: App.tsx\] が db.notes.where('embeddingStatus').equals('pending').limit(1).toArray()\[cite: db.ts\] を監視し、対象ノート（pendingEmbeddingNotes\[cite: App.tsx\]）を検出する。  
* **責務:** 対象ノート（1件ずつ処理）のembedding\[cite: db.ts\]ベクトルを取得し、DB\[cite: db.ts\]に保存する。  
* **処理フロー:**  
  1. pendingEmbeddingNotes\[cite: App.tsx\] から処理対象のノート（note）を1件取得する。  
  2. try...catch\[cite: Agents.md\] ブロックを開始する。  
  3. note.type\[cite: db.ts\] に基づいてペイロードを構築する:  
     * 'text': content: note.content as string  
     * 'image', 'sketch\_image': content: await blobToBase64(note.content as Blob)\[cite: App.tsx\]  
     * 'url': content: note.content as string (URL自体)  
     * '3d\_model', 'audio', 'project': content: null (または summarizeUrl\[cite: engram\_backend\_api\_design.ts\] を別途呼び出し、その要約テキストを使用する。v1.1ではまず null としてEmbedding対象外とし、embeddingStatus: 'completed' に即時更新するロジックを推奨)。  
  4. note.type\[cite: db.ts\]がEmbedding対象（text, image, sketch\_image, url）の場合:  
     1. embedNote (Firebase Function) \[cite: engram\_backend\_api\_design.ts\] を fetch\[cite: App.tsx\] で呼び出す。  
     2. 返された embedding: number\[\] を取得する。  
     3. db.notes.update(note.id, { embedding, embeddingStatus: 'completed', insightStatus: 'pending' })\[cite: App.tsx\] を実行する。  
  5. Embedding対象外の type\[cite: db.ts\] の場合:  
     1. db.notes.update(note.id, { embeddingStatus: 'completed', insightStatus: 'pending' })\[cite: App.tsx\] を実行する（自動接続の対象にはする）。  
  6. catch ブロック（エラー発生時）:  
     1. db.notes.update(note.id, { embeddingStatus: 'failed' })\[cite: App.tsx\] を実行する。

### **2.2. 自動接続ワーカー (useInsightWorker)**

* **トリガー:** useLiveQuery\[cite: App.tsx\] が db.notes.where({ embeddingStatus: 'completed', insightStatus: 'pending' }).limit(1).toArray()\[cite: db.ts\] を監視し、対象ノート（pendingInsightNotes\[cite: App.tsx\]）を検出する。isAiWorking\[cite: App.tsx\] が false であることも条件とする。  
* **責務:** 対象ノートと他のノートとの自動接続（Relation\[cite: data-model.md\]）を発見し、DB\[cite: db.ts\]に保存する。  
* **処理フロー:**  
  1. pendingInsightNotes\[cite: App.tsx\] から処理対象のノート（note）を1件取得する。  
  2. setIsAiWorking(true)\[cite: App.tsx\] をセットする。  
  3. try...catch\[cite: Agents.md\] ブロックを開始する。  
  4. await getInsightSuggestions(note)\[cite: App.tsx\] を呼び出す（詳細は 4\. 参照）。  
  5. db.notes.update(note.id, { insightStatus: 'completed' })\[cite: App.tsx\] を実行する。  
  6. catch ブロック（エラー発生時）:  
     1. db.notes.update(note.id, { insightStatus: 'failed' })\[cite: App.tsx\] を実行する。  
  7. finally ブロック:  
     1. setIsAiWorking(false)\[cite: App.tsx\] をセットする。

## **3\. クライアントサイド類似度計算 (similarity.ts)**

* **ファイル:** src/similarity.ts  
* **関数:** findSimilarNotes(targetNote: Note, allNotes: Note\[\], k: number): Note\[\]\[cite: similarity.ts\]  
  * **ロジック:**  
    1. targetNote.embedding\[cite: db.ts\] が存在しない場合、空配列 \[\] を返す。  
    2. allNotes\[cite: App.tsx\] をループ処理する。  
    3. note.id \=== targetNote.id または \!note.embedding の場合はスキップする。  
    4. cosineSimilarity(targetNote.embedding, note.embedding)\[cite: similarity.ts\] を計算する（dotProduct\[cite: similarity.ts\], magnitude\[cite: similarity.ts\] ヘルパー関数を使用）。  
    5. 結果を { note, similarity }\[cite: similarity.ts\] の配列に格納する。  
    6. similarity\[cite: similarity.ts\] で降順ソートし、上位 k 件を slice(0, k)\[cite: similarity.ts\] で取得して返す。  
* **関数:** cosineSimilarity, dotProduct, magnitude\[cite: similarity.ts\]（変更なし）

## **4\. ハイブリッドAIロジック（自動接続） (App.tsx 内)**

### **4.1. getInsightSuggestions(newNote: Note)\[cite: App.tsx\]**

* **責務:** newNote\[cite: db.ts\] と既存ノート間の自動接続（Relation\[cite: data-model.md\]）を、オンデバイスAIまたはクラウドAIを用いて発見する。  
* **処理フロー:**  
  1. setIsAiWorking(true)\[cite: App.tsx\] をセットする。  
  2. **コンテキスト構築:**  
     1. allDbNotes \= await db.notes.where('embeddingStatus').equals('completed').toArray()\[cite: db.ts\] を実行。  
     2. contextNotes \= findSimilarNotes(newNote, allDbNotes, 5)\[cite: App.tsx\] を実行（k=5を推奨）。  
     3. contextNotes.length \=== 0 の場合、処理を終了 (setIsAiWorking(false)\[cite: App.tsx\] を忘れずに)。  
  3. **プロンプト構築 (v1.1):**  
     1. systemPrompt: 【資料7/8】\[cite: engram\_backend\_api\_design.ts\]の findConnectionsCloud\[cite: engram\_backend\_api\_design.ts\] と共通化されたシステムプロンプト（v1.1）を使用する。「あなたは en:gram のAIアシスタントです。新しいノートと既存のノート群（コンテキスト）を受け取り、洞察に満ちた繋がりを **3件まで** 発見してください。表面的（キーワードが同じなど）な繋がりは避け、テーマ、概念、隠れたメタファーに基づいた驚きのある繋がりを優先してください。**指定されたJSON形式（{ targetNoteId: string, reasoning: string }\[\]）でのみ回答してください。**」  
     2. newNoteString: JSON.stringify(noteToTransport(newNote)) で newNote\[cite: db.ts\] をシリアライズする。  
     3. contextNotesString: contextNotes.map(noteToTransport).map(n \=\> JSON.stringify(n)).join('\\n') でコンテキストをシリアライズする。  
     4. finalPrompt \= systemPrompt \+ "\\n--- NEW NOTE \---\\n" \+ newNoteString \+ "\\n--- CONTEXT NOTES \---\\n" \+ contextNotesString  
  4. try...catch\[cite: Agents.md\] ブロック (ハイブリッド実行):  
     5\. try (第一経路: オンデバイス):  
     1\. if (typeof LanguageModel \=== 'undefined') throw new Error('LanguageModel API not available.')\[cite: App.tsx\]  
     2\. availability \= await LanguageModel.availability()\[cite: App.tsx\]  
     3\. if (availability \=== 'no') throw new Error('On-device model not supported.')\[cite: App.tsx\]  
     4\. session \= await LanguageModel.create()\[cite: App.tsx\]  
     5\. rawResult \= await session.prompt(finalPrompt)\[cite: App.tsx\]  
     6\. suggestions \= parseSuggestions(rawResult)\[cite: App.tsx\] (JSONパース処理)  
     7\. await saveSuggestions(suggestions, newNote)\[cite: App.tsx\]  
     6\. catch (error) (第二経路: クラウドフォールバック):  
     1\. console.warn('On-device AI failed, falling back to cloud.', error)\[cite: App.tsx\]  
     2\. requestData: FindConnectionsRequest \= { ... }\[cite: App.tsx\] を構築する（【資料7/8】\[cite: engram\_backend\_api\_design.ts\]のスキーマに従う。image\[cite: engram\_database\_design\_v1.1.md\]等は blobToBase64\[cite: App.tsx\] が必要）。  
     3\. result \= await findConnectionsCloud(requestData)\[cite: App.tsx\]  
     4\. suggestions \= result.data as ConnectionSuggestion\[\]\[cite: App.tsx\]  
     5\. await saveSuggestions(suggestions, newNote)\[cite: App.tsx\]  
  5. finally ブロック:  
     1. setIsAiWorking(false)\[cite: App.tsx\] をセットする。

### **4.2. ヘルパー関数**

* **noteToTransport(note: Note) (新規):**  
  * getInsightSuggestions\[cite: App.tsx\] と findConnectionsCloud\[cite: firebase.ts\] の両方で使えるよう、Note\[cite: db.ts\]オブジェクトからプロンプト/ペイロード用の簡易オブジェクトを生成する。  
  * type\[cite: db.ts\]がtext, url\[cite: engram\_database\_design\_v1.1.md\]ならcontent\[cite: db.ts\]をそのまま。image, sketch\_image\[cite: engram\_database\_design\_v1.1.md\]なら「\[Image: (説明文、またはキャプションがあればそれを)\]」。3d\_model, audio, project\[cite: engram\_database\_design\_v1.1.md\]なら「\[Note Type: (タイプ名)\]」というテキスト表現に変換する。  
* **parseSuggestions(rawResult: string) (新規):**  
  * rawResult\[cite: App.tsx\]（LLMの生出力）から、App.tsx\] を試みる。失敗した場合は空配列 \`\[\]\` を返す、堅牢なJSONパーサー。  
* **`blobToBase64(blob: Blob)`\[cite: App.tsx\]** (変更なし)

## **5\. データ保存ロジック (`App.tsx` 内)**

* **`addNote(content: string | Blob, type: NoteType)`\[cite: App.tsx\]**  
  * **v1.1:** `NoteType`\[cite: engram\_database\_design\_v1.1.md\]の全（`project`\[cite: engram\_database\_design\_v1.1.md\]や`sketch_image`\[cite: engram\_database\_design\_v1.1.md\]など）を受け入れられるようにする。  
  * `noteToAdd: Omit<Note, ...>`\[cite: App.tsx\] オブジェクトを作成する。`embeddingStatus`\[cite: db.ts\] と `insightStatus`\[cite: db.ts\] は常に `'pending'`\[cite: db.ts\] で初期化する。  
  * `await db.notes.add(noteToAdd as any)`\[cite: App.tsx\] を実行する。  
* **`saveSuggestions(suggestions: ConnectionSuggestion[], sourceNote: Note)`\[cite: App.tsx\]**  
  * `suggestions`\[cite: App.tsx\] 配列を `map()` し、`Relation`\[cite: data-model.md\] オブジェクトの配列（`relationsToAdd`\[cite: App.tsx\]）を作成する。  
  * `sourceId: sourceNote.id`, `source: 'ai_suggestion'`, `feedback: 'pending'`\[cite: data-model.md\] を設定する。  
  * `await db.relations.bulkAdd(relationsToAdd as any)`\[cite: App.tsx\] を実行する。  
* **`deleteRelation(id: string)`\[cite: InsightsPage.tsx\]** (変更なし)  
  * `db.deleteRelation(id)`\[cite: db.ts\] を呼び出す。  
* **`updateRelationFeedback(id: string, feedback: RelationFeedback)`\[cite: InsightsPage.tsx\]** (変更なし)  
  * `db.updateRelationFeedback(id, feedback)`\[cite: db.ts\] を呼び出す。

